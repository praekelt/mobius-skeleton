import json
import logging
from pprint import pprint

from channels.auth import channel_session_user, channel_session_user_from_http

from feersum import send_message_http
from kopano.utils import make_from_address
from user_channels import set_user_channel, unset_user_channel

logger = logging.getLogger(__name__)

# Convenient switch for disabling authentication checks on websockets.
# This should only be used for testing and development
# TODO: Remove
DISABLE_AUTHENTICATION = True  # settings.DEBUG

ECHO_ON = False
SEND_GREETING = False

def portal_reply(reply_channel, message):
    """
    Portal replies are for messages generated by the Portal Server.
    Examples would be message informing the user that we have a problem with
    the Feersum Engine, for instance.
    :param reply_channel: The channel to reply on (as returned by
        message.reply_channel)
    :param message: The message to send
    """
    reply_channel.send({
        "text": json.dumps({
            "type": "message",
            "pages": [{"text": message}],
            "session_event": "resume",
            "layout": "plain"
        })
    })


@channel_session_user_from_http
def ws_connect(message):
    """
    The websocket connection handler.
    """
    if DISABLE_AUTHENTICATION or message.user.is_authenticated:
        # Do setup here
        logger.debug("A websocket connection was made by {}".format(
            message.user))
        set_user_channel(message.user, message.reply_channel.name)
        # from_address = make_from_address(message.user,
        #                                  message.reply_channel.name)
        #send_message_http(from_address, event="new")
        # Accept the connection
        message.reply_channel.send({"accept": True})

        if SEND_GREETING:
            name = "Anonymous" if message.user.is_anonymous else \
                message.user.first_name or message.user.username
            portal_reply(message.reply_channel, "Hello, {}".format(name))
    else:
        message.reply_channel.send({"close": True})


@channel_session_user
def ws_disconnect(message):
    """
    The websocket disconnection handler.
    """
    if DISABLE_AUTHENTICATION or message.user.is_authenticated:
        logger.debug("{} disconnected a websocket".format(message.user))
        unset_user_channel(message.user, message.reply_channel.name)
    else:
        message.reply_channel.send({"close": True})


@channel_session_user
def ws_receive(message):
    if DISABLE_AUTHENTICATION or message.user.is_authenticated:
        logger.debug("A websocket message was received from {}".format(message.user))
        logger.debug("Websocket message.content {}".format(message.content))
        # Handle message
        # TODO: Pass message on to Feersum Engine via HTTP call
        # We need to figure out how to name the user in the message
        # so that responses can be mapped back appropriately.
        pprint(message)
        feersum_frame = json.loads(message.content["text"])
        if feersum_frame["type"] == "message":

            from_address = make_from_address(message.user,
                                             message.reply_channel.name)
            if "content" in feersum_frame:
                if ECHO_ON:
                    portal_reply(message.reply_channel, feersum_frame[
                        "content"])

                ask_for_forgiveness = not send_message_http(
                    from_address,
                    text=feersum_frame["content"]
                )
            else:
                ask_for_forgiveness = not send_message_http(
                    from_address,
                    postback=feersum_frame["postback"]
                )

            if ask_for_forgiveness:
                portal_reply(
                    message.reply_channel, "Something went wrong. Please "
                                           "try again later.")
    else:
        message.reply_channel.send({"close": True})
